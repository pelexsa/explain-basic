특징
절차 지향, 구조적 프로그래밍
객체지향 언어
일반화 프로그래밍 → 3가지 모두 지원

파일 실행 순서
소스 파일 → 전처리기 → 컴파일러 → 오브젝트 파일 → 링커 (시동 코드, 표준 라이브러리) → 실행 파일

전처리기(선행처리기)
텍스트 대체(#define)와 조건부 컴파일(#ifdef, #ifndef ..etc) 수행
# 기호로 시작하는 특수 문인 전처리기 지시어를 처리하는 역할을 한다.

구현 내용을 추상화 하거나, 헤더 파일, 매크로를 모듈화하게 되면 관리에 용이 할 수 있으나,
남용하면 디버깅 시, 파일들 간 이동 및 수정이 어려워 필요한 파일만 모듈화

헤더 파일 처리
#include를 통해 외부에 선언된 함수, 상수 사용 가능

모듈화 시켜놓은 파일 헤더 주의점
예를 들어, 함수를 모듈화 시켜놓은 파일이 있는데
using namespace std; 를 전역변수로 선언해두게 되면
해당 모듈화 파일을 include하는 모든 파일에서 선언되기 때문에
함수내에서 선언하는것이 효율적이다.


매크로 처리
#define 명령어를 사용하여 빌드 하기전에 실행 되며,
#ifdef 해당 매크로가 기존에 정의되어 있는지를 확인

매크로 확장
전처리기는 매크로를 정의하고 확장할 수 있습니다. 매크로는 기본적으로 더 긴 코드 시퀀스에 대한 단축 표기법을 정의할 수 있는 텍스트 대체입니다. 매크로는 #define 디렉티브를 사용하여 정의됩니다.

조건부 컴파일
프리프로세서는 #define을 사용하여 정의된 프리프로세서 매크로를 기반으로 코드의 특정 부분을 조건부로 컴파일할 수 있습니다. 이렇게 하면 다른 플랫폼에 대해 또는 다른 기능을 사용하도록 설정된 다른 버전의 코드를 컴파일할 수 있습니다.

컴파일러 제어
프리프로세서는 또한 어떤 언어 표준을 사용할지 또는 어떤 컴파일러 특정 기능을 사용할지 지정하는 등 컴파일러의 동작을 제어하는 데 사용될 수 있다.


전처리기 지시어
header file process 
	#include를 통해 외부에 선언된 함수, 상수 사용 가능

매크로 처리
1. #ifdef, #else #endif
#define 명령어를 사용하여 빌드 하기전에 실행 되며,
#ifdef 해당 매크로가 기존에 정의되어 있는지를 확인

현재 파일내에서만 적용

ex)
#include <iostream>
using namespace std;

#define LIKE APPLE

int main() {
// 1번 예시
#ifdef LIKE_APPLE
	cout << "Apple" << endl;
#endif

#ifndef LIKE_APPLE
	cout << "Orange" << endl;
#endif

//2번 예시
#ifdef LIKE_APPLE
	cout << "Apple" << endl;
#else
	cout << "Orange" << endl;
#endif

	return 0;
}

컴파일러
cpp 원시 파일을 이진수로 변환 시켜주는 작업
cpp file → object file(.o, .obj)로 변환

링커
object file + 시동코드(start-up code) + library code를 하나의 파일로 만드는 작업

실행 파일
전처리기 → 컴파일러 → 링커 작업 후 .exe 실행파일 생성
